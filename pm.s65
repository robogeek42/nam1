; pacman - draw map

.setcpu "65C02"

.include "macros.inc65"
.include "zeropage.inc65"
.include "acia.inc65"
.include "io.inc65"
.include "string.inc65"
.include "video.inc65"
.include "video_common.inc65"
.include "video_registers.inc65"
.include "sprite.inc65"
.include "bcd.inc65"
.include "kbdvia.inc65"
.include "scancodes.inc65"
.include "pckybd.inc65"

.export pacman

; pacman vars in basic program area
pm_vars = $7000

; game state 0 = not started 1 = playing  FF =  quit
pm_game = pm_vars + 0
pm_allowed = pm_vars + 1
pm_input_dir = pm_vars + 2
KBD_LAST_ROW = pm_vars + 3
KBD_LAST_COL = pm_vars + 4

; positions (x,y) and direction for each actor
pm_positions = pm_vars + 5

; PACMAN position info
PM_NT_LO = pm_positions+0   ; map (name table) position
PM_NT_HI = pm_positions+1   ; map (name table) position
PM_DIR = pm_positions+2   ; Direction
; Ghost 1
G1_X = pm_positions+3
G1_Y = pm_positions+4
G1_D = pm_positions+5
G1_M = pm_positions+6   ; Mode (0=norm 1=scared)
; Ghost 2
G2_X = pm_positions+7
G2_Y = pm_positions+8
G2_D = pm_positions+9
G2_M = pm_positions+10
; Ghost 3
G3_X = pm_positions+11
G3_Y = pm_positions+12
G3_D = pm_positions+13
G3_M = pm_positions+14
; only 3 for now ...
pm_positions_end = pm_positions+14      ; (15)

; sprite data table, 4 bytes per sprite
; Y, X, Pattern No, Color/EarlyFlag
; starts with number of sprites enabled

PM_UPDATE_FLAG = pm_positions_end +1 ; flag 1 = update sprites

pm_sprite_table = pm_positions_end + 2

PM_NUMPRITES = pm_sprite_table+0

PM_ST_SPR1_Y = pm_sprite_table+1    ; (19)
PM_ST_SPR1_X = pm_sprite_table+2
PM_ST_SPR1_P = pm_sprite_table+3
PM_ST_SPR1_C = pm_sprite_table+4

PM_ST_SPR2_Y = pm_sprite_table+5
PM_ST_SPR2_X = pm_sprite_table+6
PM_ST_SPR2_P = pm_sprite_table+7
PM_ST_SPR2_C = pm_sprite_table+8

PM_ST_SPR3_Y = pm_sprite_table+9
PM_ST_SPR3_X = pm_sprite_table+10
PM_ST_SPR3_P = pm_sprite_table+11
PM_ST_SPR3_C = pm_sprite_table+12

PM_ST_SPR4_Y = pm_sprite_table+13
PM_ST_SPR4_X = pm_sprite_table+14
PM_ST_SPR4_P = pm_sprite_table+15
PM_ST_SPR4_C = pm_sprite_table+16

PM_ST_SPR5_Y = pm_sprite_table+17
PM_ST_SPR5_X = pm_sprite_table+18
PM_ST_SPR5_P = pm_sprite_table+19
PM_ST_SPR5_C = pm_sprite_table+20

pm_sprite_table_end = pm_sprite_table+20

pm_local =  pm_sprite_table_end+1

IRQ_OLD      = pm_local+0  ; 2 bytes
PM_IRQCOUNT    = pm_local+2
PM_INTERRUPT = pm_local+3

PM_SCORE = pm_local+8       ; 2 bytes
PM_STR_BUFFER = pm_local+10  ; 12 bytes

; IRQ location - points to address part of JMP xxxx
IRQ_ADDR = $20A

.code

;------------------------------------------------------------------
; 1. Load chars to consecutive locations in 
; MODE 2 pattern table
;
pm_loadchars:
            ld16 TMP0,PM_CHAR_TAB       ; character defs
pmdm_loop2: LDY #0
pmdm_loop1: LDA (TMP0),Y
            JSR vdp_write
            INY
            BNE pmdm_loop1              ; loop 256 times = 32 8byte chars
            RTS
pacman:
pm_drawmaze:
            phx
            phy
            LDA #2                      ; MODE 2
            JSR vdp_set_mode
            LDA #$F0
            JSR vdp_set_base_colors

            JSR vdp_setaddr_pattern_table
            JSR pm_loadchars

            ; load chars twice more
            LDA #$08
            STA TMP0
            JSR vdp_setaddr_pattern_table_offset
            JSR pm_loadchars

            LDA #$10
            STA TMP0
            JSR vdp_setaddr_pattern_table_offset
            JSR pm_loadchars

;------------------------------------------------------------------
; 2. Colours - Blue for maze, yellow for pills & dots
pm_loadcols:
            LDA #3
            STA TMP0+1

            LDA VDP_REGS+3      ;; Color table
            AND #$80            ;; just want upper bit
            CLC
            ROR
            ROR
            STA TMP0            ; TMP 0 has msb of color table
pmdm_colloop:
            LDY #0
            LDA TMP0
            JSR vdp_set_addr_w

            LDA #$40                    ; Blue/black
            LDX #28                     ; 28 characters
pmdm_loop4: LDY #8                      ; 8 bytes per char
pmdm_loop3: JSR vdp_write
            DEY
            BNE pmdm_loop3
            DEX
            BNE pmdm_loop4

            LDA #$90                    ; Yellow/black
            LDX #4                      ; 4 characters
pmdm_loop6: LDY #8                      ; 8 bytes per char
pmdm_loop5: JSR vdp_write
            DEY
            BNE pmdm_loop5
            DEX
            BNE pmdm_loop6
         
            CLC                         ; Add 2048 to address (8 to hi)
            LDA TMP0
            ADC #$08
            STA TMP0

            DEC TMP0+1                  ; we do the colour load 3 times
            LDA TMP0+1
            BNE pmdm_colloop

;------------------------------------------------------------------
; 3. Load pattern to name table
;    Screen is 32x24 characters
pm_loadnames:
            JSR vdp_setaddr_name_table
            ld16 TMP0, PACMAN_MAZE
            LDX #24
pmdm_loop8: LDY #0 
pmdm_loop7: LDA (TMP0),Y
            JSR vdp_write
            INY
            CPY #32                     ; 32 chars per line
            BNE pmdm_loop7
            add8To16 #32, TMP0
            DEX
            BNE pmdm_loop8
;------------------------------------------------------------------
; 4. Load game map 32x24
;            ld16 TMP2, pm_map           ; set address of internal map
;            ld16 TMP0, PACMAN_MAP       ; 
;            LDX #3                      ; 3 * 256
;pmdm_loop10: LDY #0 
;pmdm_loop9: LDA (TMP0),Y
;            STA (TMP2),Y
;            INY
;            BNE pmdm_loop9
;            add8To16 #32, TMP0
;            add8To16 #32, TMP2
;            DEX
;            BNE pmdm_loop10

;------------------------------------------------------------------
; Init and Set sprite type (8x8 unmag)
            JSR vdp_init_sprites
            JSR spr_set_small
            JSR spr_set_mag_off

;------------------------------------------------------------------
; Load sprite patterns
            ld16 ZP_TMP0, PM_SPRITES
            STZ ZP_TMP2                ; load into P=0,1 ...
@next_pattern:
            JSR vdp_load_sprite_data_from_mem
            CLC
            add8To16 #8,ZP_TMP0        ; move data ptr to next pattern
            INC ZP_TMP2                ; inrement pattern numner
            LDA ZP_TMP2
            CMP #PM_NUM_SPRITE_PATTERNS
            BNE @next_pattern

;------------------------------------------------------------------
; Initialise sprite table
            LDA #112
            STA PM_ST_SPR1_X
            LDA #144
            STA PM_ST_SPR1_Y
            LDA #0
            STA PM_ST_SPR1_P
            LDA #11
            STA PM_ST_SPR1_C

            LDA #0
            STA PM_ST_SPR2_X
            LDA #0
            STA PM_ST_SPR2_Y
            LDA #9
            STA PM_ST_SPR2_P
            LDA #14
            STA PM_ST_SPR2_C

            LDA #1
            STA PM_NUMPRITES
;------------------------------------------------------------------
; Initialise Positon data
; start at (14,18) = (14+18*32)=590=$24E
            LDA #$4E
            STA PM_NT_LO
            LDA #$02
            STA PM_NT_HI
            LDA #PM_DIR_L              ; facing left
            STA PM_DIR

;------------------------------------------------------------------
; Enable sprites
            LDA #1                     ; enable 1 sprite
            STA ZP_TMP0                ; Pass number of sprites in ZP_TMP0
            JSR vdp_enable_sprites

;------------------------------------------------------------------
; write score
            STZ PM_SCORE
            STZ PM_SCORE+1
            JSR pm_draw_score

.ifdef PS2K
; init keyboard
            jsr KBINIT
            lda #0
            sta KBD_FLAGS ; use KBD_FLAGS zp var to hold key flags
                          ; 7  6  5  4  3  2  1  0
                          ;             a  s  d  w
.endif

;------------------------------------------------------------------
; Setup interrupt handler
pmih_save_old:
            LDA IRQ_ADDR
            STA IRQ_OLD
            LDA IRQ_ADDR+1
            STA IRQ_OLD+1

            LDA #$00
            STA PM_IRQCOUNT

            LDA #<PM_IRQ
            STA IRQ_ADDR
            LDA #>PM_IRQ
            STA IRQ_ADDR+1

; Enable VDP IRQ output (every 1/60th second)
            LDA VDP_REGS+1      ;; data to write is existing Reg1 (was set by MODE command)
            ORA #$20            ;; with bit2 set - actually bit 5 if numbered from LSb like sensible chips
            STA VDP_REGS+1
            LDY #$81            ;; register to write (1)
            JSR vdp_regwrite

            JSR vdp_getstatus   ;; clear interrupt flag in VDP

; Start allowing interrupts at CPU
            CLI

;------------------------------------------------------------------
; GAME LOOP
;
            STZ pm_game         ; start at state 0 - not playing yet
            JSR pm_readmap      ; get allowed directions
            STA pm_allowed

game_loop:
gl_dogame:
            LDA PM_INTERRUPT        ; check interrupt has happened
            BNE gl_get_input
            JMP game_loop

gl_get_input:
            LDA #0
            STA PM_INTERRUPT        ; reset interrupt flag

            JSR pm_get_input_serial
.ifdef KEYB
            JSR pm_get_input_keyboard
.endif
.ifdef PS2K
            JSR pm_get_input_ps2k
.endif
            JSR pm_readmap
            STA pm_allowed

            JSR pm_process_input

            LDA pm_game		; check game state:
            CMP #$00		; 	game not started?
            BEQ game_loop	; 		yes, keep just checking input
            CMP #$FF		; 	quit requested?
            BNE gl_do_update	; 		no, then continue
            JMP quit_game	; 		yes, quit

gl_do_update:
			; check if is in square
            LDA PM_DIR                ; check depends on direction of movement U/D or L/R
            CMP #PM_DIR_D             ;
            BCS gl_check_vert         ; >= Down = Down/Up

            LDA PM_ST_SPR1_X
            AND #$04				; 0-3, in square, 4-7 in square to right
			BNE gl_update_pm        ; not in square
            BRA gl_do_insquare

gl_check_vert:
            LDA PM_ST_SPR1_Y
            AND #$04				; 0-3, in square, 4-7 in square below
			BNE gl_update_pm        ; not in square
			
gl_do_insquare:
            JSR pm_read_nametable
            CMP #28                 ; 28 = dot
            BEQ gl_is_dot
            CMP #29
            BEQ gl_is_pill
            
            JMP gl_update_pm

gl_is_dot:
            ; dot = add 10 to score
			add8To16 #10, PM_SCORE
            JMP gl_update_score
            
gl_is_pill:
            ; pill = add 50 to score
			add8To16 #50, PM_SCORE

gl_update_score:
            ; display new score
            JSR pm_draw_score

            ; write to name table - space
            JSR pm_write_nametable

gl_update_pm:
			JSR pm_update_pm_sprite

			;JSR pm_update_debug_square

            LDA #1
            STA PM_UPDATE_FLAG   ; tell update routine to update sprites

gl_move_pacman:
            LDA PM_IRQCOUNT                 ; update every N ticks
            AND #$01                        ; N=2 
            BNE gl_skip_update
            LDA PM_DIR
            CMP #PM_DIR_R
            BEQ gl_move_right
            CMP #PM_DIR_L
            BEQ gl_move_left
            CMP #PM_DIR_U
            BEQ gl_move_up
            CMP #PM_DIR_D
            BEQ gl_move_down
            JMP gl_skip_update

gl_move_right:
            JSR pm_move_right
            JMP gl_skip_update
gl_move_left:
            JSR pm_move_left
            JMP gl_skip_update
gl_move_up:
            JSR pm_move_up
            JMP gl_skip_update
gl_move_down:
            JSR pm_move_down

gl_skip_update:
            JMP game_loop

;------------------------------------------------------------------
pm_move_left:
            ; if pos is at left of current square then move
            ; to next square of pos. Otherwise just move
            LDA PM_ST_SPR1_X
            AND #$07
            BNE pml_decx         ; not 0 (fully in square) so keep moving

            ; check allowed directions
            LDA pm_allowed
            AND #PM_MAP_DIR_L_BIT
            BEQ pml_skipx

            ; decrement PM pos (absolute)
            dec16 PM_NT_LO
pml_decx:
            DEC PM_ST_SPR1_X
pml_skipx:
            RTS
pm_move_right:
            ; if pos is at far right of current square then move
            ; to next square of pos. Otherwise just move
            LDA PM_ST_SPR1_X
            AND #$07
            CMP #$07
            BNE pml_incx         ; not 7 so keep moving

            ; check allowed directions
            LDA pm_allowed
            AND #PM_MAP_DIR_R_BIT
            BEQ pml_skipx

            ; increment PM pos (absolute)
            inc16 PM_NT_LO
            INC PM_ST_SPR1_X
            RTS
pml_incx:
            ; check allowed directions
            LDA pm_allowed
            AND #PM_MAP_DIR_R_BIT
            BEQ pml_skipx
            INC PM_ST_SPR1_X
            RTS

pm_move_up:
            ; if pos is at top of current square then move
            ; to next square of pos. Otherwise just move
            LDA PM_ST_SPR1_Y
            AND #$07
            BNE pml_decy         ; not 0 (fully in square) so keep moving

            ; check allowed directions
            LDA pm_allowed
            AND #PM_MAP_DIR_U_BIT
            BEQ pml_skipy

            ; subtract 32 from PM pos (absolute)
            sub8From16 #32, PM_NT_LO
pml_decy:
            DEC PM_ST_SPR1_Y
pml_skipy:
            RTS
pm_move_down:
            ; if pos is at bottom right of current square then move
            ; to next square of pos. Otherwise just move
            LDA PM_ST_SPR1_Y
            AND #$07
            CMP #$07
            BNE pml_incy         ; not 7 so keep moving

            ; check allowed directions
            LDA pm_allowed
            AND #PM_MAP_DIR_D_BIT
            BEQ pml_skipy

            ; add 32 to PM pos (absolute)
            add8To16 #32, PM_NT_LO
            INC PM_ST_SPR1_Y
            RTS
pml_incy:
            LDA pm_allowed
            AND #PM_MAP_DIR_D_BIT
            BEQ pml_skipy
            INC PM_ST_SPR1_Y
            RTS
 
 
;------------------------------------------------------------------
; Exit
quit_game:
            JSR pm_quit_game
            ply
            plx
            RTS

;==================================================================
; Subroutines

; Read game map at position PM_NT_LO/HI
pm_readmap: CLC
            LDA #<PACMAN_MAP
            ADC PM_NT_LO
            STA TMP2
            LDA #>PACMAN_MAP
            ADC PM_NT_HI
            STA TMP2+1
            LDY #0
            LDA (TMP2),Y
            RTS

; read from name table
pm_read_nametable:
            LDY PM_NT_LO             ;; Set VRAM address to name table (VDP_REG2 * 0x400) + PM_NT_LO/HI
            LDA VDP_REGS+2
            ASL
            ASL
            CLC
            ADC PM_NT_HI
            JSR vdp_set_addr_r
            LDA VDP_RD_VRAM
            RTS
; write to name table
pm_write_nametable:
            LDY PM_NT_LO             ;; Set VRAM address to name table (VDP_REG2 * 0x400) + PM_NT_LO/HI
            LDA VDP_REGS+2
            ASL
            ASL
            CLC
            ADC PM_NT_HI
            JSR vdp_set_addr_w
            LDA #0
            STA VDP_WR_VRAM
            RTS

;---------------------------------------
; Get input from ACIA
pm_get_input_serial:
            LDA ACIA_STATUS
            AND #ACIA_STATUS_RX_FULL
            BEQ gis_no_dir_input
            LDA ACIA_DATA

            CMP #'q'
            BNE gis_check_space
            LDA #$FF
            STA pm_game
            RTS
gis_check_space:
            CMP #' '
            BNE gis_check_wasd
            LDA #$01
            STA pm_game
            RTS
gis_check_wasd:
            CMP #'a'
            BNE @check_d
            LDA #PM_DIR_L
            STA pm_input_dir
            RTS
@check_d:   CMP #'d'
            BNE @check_w
            LDA #PM_DIR_R
            STA pm_input_dir
            RTS
@check_w:   CMP #'w'
            BNE @check_s
            LDA #PM_DIR_U
            STA pm_input_dir
            RTS
@check_s:   CMP #'s'
            BNE gis_no_dir_input
            LDA #PM_DIR_D
            STA pm_input_dir
            RTS
gis_no_dir_input:
            ;LDA #$FF
            ;STA pm_input_dir
            RTS

.ifdef KEYB
debug_row_col:
            ; DEBUG
            ld16 R0,PM_STR_BUFFER
            LDA KBD_ROW
            JSR fmt_bin_string
            JSR acia_puts
            LDA #' '
            JSR acia_putc
            LDA KBD_COL
            JSR fmt_bin_string
            JSR acia_puts
            JSR acia_put_newline
            RTS
;---------------------------------------
; Get input from KEYBOARD
pm_get_input_keyboard:
            JSR kbd_getkey              ; result in KBD_COL, KBD_ROW (zero-page)
            BCC gik_earlyexit           ; No key pressed
            LDA KBD_ROW                 ; Check of the same key again
            CMP KBD_LAST_ROW
            BNE gik_got_key             ; New key - process
            LDA KBD_COL
            CMP KBD_LAST_COL
            BNE gik_got_key             ; New key - process

gik_earlyexit:
            RTS

gik_got_key:
            LDA KBD_ROW                 ; save last
            STA KBD_LAST_ROW
            LDA KBD_COL
            STA KBD_LAST_COL

            JSR debug_row_col

gik_repeat:
            ; q and <spc> in row 0
            ; a, w, s are in row 1
            ; d in row 2
            BBS0 KBD_ROW,gik_test_row0
            BBS1 KBD_ROW,gik_test_row1
            BBS2 KBD_ROW,gik_test_row2
            JMP gik_done

gik_test_row0:
			BBS4 KBD_COL,gik_do_spc
			BBS6 KBD_COL,gik_do_q
			RMB0 KBD_ROW				; no columns set (anymore) so reset row bit
            BRA gik_repeat
gik_test_row1:
			BBS1 KBD_COL,gik_do_w
			BBS2 KBD_COL,gik_do_a
			BBS5 KBD_COL,gik_do_s
			RMB1 KBD_ROW				; no columns set (anymore) so reset row bit
            BRA gik_repeat
gik_test_row2:
			BBS2 KBD_COL,gik_do_d
			RMB2 KBD_ROW				; no columns set (anymore) so reset row bit
            BRA gik_repeat

gik_do_spc:								; SPACE = Start Game
			LDA #$01					; Start game flag
            STA pm_game
			RMB4 KBD_COL
            BRA gik_repeat
gik_do_q:								; Q = Quit Game
            LDA #$FF                    ; else mark end-of-game
            STA pm_game                 ; in game state variable
			RMB6 KBD_COL
            BRA gik_repeat
gik_do_w:								; W = Up
            LDA #PM_DIR_U
            STA pm_input_dir
			RMB1 KBD_COL
            BRA gik_repeat
gik_do_a:								; A = Left
            LDA #PM_DIR_L
            STA pm_input_dir
			RMB2 KBD_COL
            BRA gik_repeat
gik_do_s:								; S = Down
            LDA #PM_DIR_D
            STA pm_input_dir
			RMB5 KBD_COL
            BRA gik_repeat
gik_do_d:								; D = Right
			LDA #PM_DIR_R
			STA pm_input_dir
			RMB2 KBD_COL
            BRA gik_repeat
gik_done:
            RTS
.endif

.ifdef PS2K
pm_get_input_ps2k:
            jsr KBSCAN_GAME
            bcc gip_done
            ldx #0                  ; 0 in X means this is a make code
            lda KBD_CHAR
            cmp #SC_DONOTHING       ; check for a break code
            bne gip_skip_set_breakcode

            ; dont care about release
            rts
            ;lda KBD_SPECIAL         ; get break code
            ;beq gip_done
            ;ldx #1                  ; 1 in X means this is a break code
        
gip_skip_set_breakcode:
            cmp #SC_A
            beq gip_do_LEFT
            cmp #SC_RAW_LEFT_ARROW
            beq gip_do_LEFT
            ;cmp #SC_NC_LEFT_ARROW
            ;beq gip_do_LEFT

            cmp #SC_D
            beq gip_do_RIGHT
            cmp #SC_RAW_RIGHT_ARROW
            beq gip_do_RIGHT
            ;cmp #SC_NC_RIGHT_ARROW
            ;beq gip_do_RIGHT

            cmp #SC_W
            beq gip_do_UP
            cmp #SC_RAW_UP_ARROW
            beq gip_do_UP
            ;cmp #SC_NC_UP_ARROW
            ;beq gip_do_UP

            cmp #SC_S
            beq gip_do_DOWN
            cmp #SC_RAW_DOWN_ARROW
            beq gip_do_DOWN
            ;cmp #SC_NC_DOWN_ARROW
            ;beq gip_do_DOWN

            cmp #SC_SPC
            beq gip_do_START
            cmp #SC_Q
            beq gip_do_QUIT

gip_done:
            rts

gip_do_QUIT:
            lda #$FF
            sta pm_game
            rts
gip_do_START:
            lda #$01
            sta pm_game
            rts
gip_do_LEFT:
            lda #PM_DIR_L
            sta pm_input_dir
            rts
gip_do_RIGHT:
            lda #PM_DIR_R
            sta pm_input_dir
            rts
gip_do_UP:
            lda #PM_DIR_U
            sta pm_input_dir
            rts
gip_do_DOWN:
            lda #PM_DIR_D
            sta pm_input_dir
            rts
.endif

;---------------------------------------
; Process input in terms of 0=L,1=R,2=U,3=D
pm_process_input:
            LDA pm_input_dir
            BMI pi_done         ; $FF = no input
            ; if current dir is same as direction it is moving in, ignore
            CMP PM_DIR
            BEQ pi_done

            ; switch to either processing up/down or left/right
            LDA PM_DIR          ; check current direction
            CMP #PM_DIR_D
            BCS pi_curr_is_UD   ; 2 or 3 D/U

pi_curr_is_LR:            
            LDA pm_input_dir
            CMP #PM_DIR_L
            BEQ pi_dir_left
            CMP #PM_DIR_R
            BEQ pi_dir_right

            LDA PM_ST_SPR1_X
            AND #$07            ; if X%8==0
            BEQ pi_check_ud     ;   then fully in square so can check U/D as well
            ;CMP #$01            ; if X%8==1
            ;BNE pi_done         ;   then almost in square so
            ;LDA PM_ST_SPR1_X    ;   push to align
            ;AND #$F8            ;   by setting position in square to 0
            ;STA PM_ST_SPR1_X
            BRA pi_done

pi_check_ud:
            LDA pm_input_dir
            CMP #PM_DIR_U
            BEQ pi_dir_up
            CMP #PM_DIR_D
            BEQ pi_dir_down
pi_done:
            ;LDA #$FF            ; clear input once it has been processed
            ;STA pm_input_dir
            RTS

pi_curr_is_UD:            
            LDA pm_input_dir
            CMP #PM_DIR_U
            BEQ pi_dir_up
            CMP #PM_DIR_D
            BEQ pi_dir_down

            LDA PM_ST_SPR1_Y
            AND #$07            ; if Y%8==0
            BEQ pi_check_lr     ;   then fully in square so can check L/R as well
            ;CMP #$01            ; if Y%8==1
            ;BNE pi_done         ;   then almost in square so
            ;LDA PM_ST_SPR1_Y    ;   push to align
            ;AND #$F8
            ;STA PM_ST_SPR1_Y
            BRA pi_done

pi_check_lr:
            LDA pm_input_dir
            CMP #PM_DIR_L
            BEQ pi_dir_left
            CMP #PM_DIR_R
            BEQ pi_dir_right
            RTS

pi_dir_right:
            LDA pm_allowed
            AND #PM_MAP_DIR_R_BIT
            BEQ @skip
            LDA #PM_DIR_R
            STA PM_DIR
@skip:      RTS
pi_dir_left:
            LDA pm_allowed
            AND #PM_MAP_DIR_L_BIT
            BEQ @skip
            LDA #PM_DIR_L
            STA PM_DIR
@skip:      RTS
pi_dir_up:
            LDA pm_allowed
            AND #PM_MAP_DIR_U_BIT
            BEQ @skip
            LDA #PM_DIR_U
            STA PM_DIR
@skip:      RTS
pi_dir_down:
            LDA pm_allowed
            AND #PM_MAP_DIR_D_BIT
            BEQ @skip
            LDA #PM_DIR_D
            STA PM_DIR
@skip:      RTS

;------------------------------------------------------------------
; Quit
pm_quit_game:
            ld16 R0,quit_message
            JSR acia_puts
; restore interrupt vector 
            LDA IRQ_OLD
            STA IRQ_ADDR
            LDA IRQ_OLD+1
            STA IRQ_ADDR+1
; disable interrupts at CPU
            SEI

; disable interrupts from VDP
            LDA VDP_REGS+1      ;; data to write is existing Reg1
            AND #$DF            ;; unset interrupt bit
            STA VDP_REGS+1
            LDY #$81            ;; register to write (1)
            JSR vdp_regwrite

            JSR vdp_getstatus   ;; clear interrupt flag in VDP

            RTS

;------------------------------------------------------------------
; IRQ Handler
PM_IRQ:		PHP                         ; save status flags (so BCD is correct)
            PHA
            JSR pm_draw_sprites
			DEC PM_IRQCOUNT             ;; count--
            DEC PM_INTERRUPT            ;; make interrupt flag != 0

@skip:		JSR vdp_getstatus           ;; read VDP status to reenable the VDP interrupt
            PLA 
            PLP
			RTI

;------------------------------------------------------------------
; draw sprites from table
pm_draw_sprites:
            LDA PM_UPDATE_FLAG
            BNE pm_do_draw
            RTS
pm_do_draw:
            phx
            phy
            LDA PM_NUMPRITES            
            BEQ pds_done
            ASL                         ; 4 bytes per sprite
            ASL
            TAX                         ; X has size of table

            LDY ZP_VDP_SAB              ; set vdp up to write to Sprite Attrib Base
            LDA ZP_VDP_SAB+1
            JSR vdp_set_addr_w
            LDY #0                      ; index into table
pds_loop1:
            LDA PM_ST_SPR1_Y,Y          ; read byte from table
            JSR vdp_write               ; wrie to VDP
            INY
            DEX
            BNE pds_loop1
pds_done:
            STZ PM_UPDATE_FLAG
            ply
            plx
            RTS
            

;------------------------------------------------------------------
; Draw score to screen
pm_draw_score:
            ; put score into R1,R+1
            LDA PM_SCORE
            STA R1
            LDA PM_SCORE+1
            STA R1+1
            ; convert to decimal
            JSR BINBCD16
            ld16 R0,PM_STR_BUFFER
            JSR BCD4BYTE2STR
            
            LDA #27             ; X
            LDY #9              ; Y
            JSR vdp_set_pos
            JSR vdp_write_text  
            RTS
            
pm_print_debug:
            ld16 R0,PM_STR_BUFFER
            LDA R4+1
            JSR fmt_hex_string
            add8To16 #2, R0
            LDA R4
            JSR fmt_hex_string
            ld16 R0,PM_STR_BUFFER
            LDA #27             ; X
            LDY #13             ; Y
            JSR vdp_set_pos
            JSR vdp_write_text  
            RTS

;------------------------------------------------------------------
; update the PM sprite animation
pm_update_pm_sprite:
            LDA PM_IRQCOUNT
            AND #%00011000          ; change sprite from 0-3 every 8th tick
            LSR
            LSR
            LSR
            ; add 4*PM_DIR
            STA TMP0
            LDA PM_DIR                ; direction 
            ASL
            ASL
            CLC
            ADC TMP0
            ; lookup sprite number
            TAY
            LDA PM_SPR_INDEX,Y
            ; store in pattern
            STA PM_ST_SPR1_P
			RTS

;------------------------------------------------------------------
; update the white Debug square (in sprite 2)
pm_update_debug_square:
			; debug square sprite
			; calculate X/Y from the memory position in PM_NT_HI/LO
			LDA PM_NT_HI
			STA R3+2
			LDA PM_NT_LO
			STA R3
			AND #$1F        ; remainder after divide by 32
			ASL
			ASL
			ASL             ; * 8 to give X
			STA PM_ST_SPR2_X
			
			CLC
			LDA R3
			AND #$E0
			STA R3

			ROR R3+2    ; /2
			ROR R3
			CLC
			ROR R3+2    ; /4
			ROR R3
			LDA R3
			STA PM_ST_SPR2_Y
			RTS

quit_message:
	.byte "Goodbye!",$0d,$0a,$00

.include "pm_char_set.inc65"
.include "pm_char_map.inc65"
.include "pm_sprites.inc65"
.include "pm_map.inc65"
