; vim: ts=4 sw=4
; pacman - draw map

.setcpu "65C02"

.include "macros.inc65"
.include "zeropage.inc65"
.include "acia.inc65"
.include "io.inc65"
.include "string.inc65"
.include "video.inc65"
.include "video_common.inc65"
.include "video_registers.inc65"
.include "sprite.inc65"
.include "bcd.inc65"
.include "kbdvia.inc65"
.include "scancodes.inc65"
.include "pckybd.inc65"
.include "colors.inc65"

.export pacman

; pacman vars in basic program area
buffer = $6C00
pm_vars = $7000

; game state 0 = not started 1 = playing  FF =  quit
pm_game = pm_vars + 0
pm_allowed = pm_vars + 1
pm_input_dir_mask = pm_vars + 2
KBD_LAST_ROW = pm_vars + 3
KBD_LAST_COL = pm_vars + 4

; positions (x,y) and direction for each actor
pm_positions = pm_vars + 5

; PACMAN position info
PM_NT_LO = pm_positions+0   ; map (name table) position
PM_NT_HI = pm_positions+1   ; map (name table) position
PM_POS_X = pm_positions+2 ; PM position in chars on screen
PM_POS_Y = pm_positions+3
PM_DIR_NUM = pm_positions+4  ; PM Direction in sprite num 0=R,1=L,2=D,3=U
PM_DIR_MASK = pm_positions+5	; current movement dir of PM
								; bit field  3210
								;            UDLR

; Ghost 1
G1_X = pm_positions+6
G1_Y = pm_positions+7
G1_D = pm_positions+8   ; Direction
G1_M = pm_positions+9   ; Mode (0=norm 1=scared)
; Ghost 2
G2_X = pm_positions+10
G2_Y = pm_positions+11
G2_D = pm_positions+12
G2_M = pm_positions+13
; Ghost 3
G3_X = pm_positions+14
G3_Y = pm_positions+15
G3_D = pm_positions+16
G3_M = pm_positions+17
;
; only 3 ghosts for now ...

pm_sprite_table = pm_positions+18

; sprite data table, 4 bytes per sprite
; Y, X, Pattern No, Color/EarlyFlag
; starts with number of sprites enabled

PM_NUMPRITES = pm_sprite_table+0

PM_ST_SPR1_Y = pm_sprite_table+1	; 
PM_ST_SPR1_X = pm_sprite_table+2
PM_ST_SPR1_P = pm_sprite_table+3
PM_ST_SPR1_C = pm_sprite_table+4

PM_ST_SPR2_Y = pm_sprite_table+5
PM_ST_SPR2_X = pm_sprite_table+6
PM_ST_SPR2_P = pm_sprite_table+7
PM_ST_SPR2_C = pm_sprite_table+8

PM_ST_SPR3_Y = pm_sprite_table+9
PM_ST_SPR3_X = pm_sprite_table+10
PM_ST_SPR3_P = pm_sprite_table+11
PM_ST_SPR3_C = pm_sprite_table+12

PM_ST_SPR4_Y = pm_sprite_table+13
PM_ST_SPR4_X = pm_sprite_table+14
PM_ST_SPR4_P = pm_sprite_table+15
PM_ST_SPR4_C = pm_sprite_table+16

PM_ST_SPR5_Y = pm_sprite_table+17
PM_ST_SPR5_X = pm_sprite_table+18
PM_ST_SPR5_P = pm_sprite_table+19
PM_ST_SPR5_C = pm_sprite_table+20

pm_sprite_table_end = pm_sprite_table+20

pm_local =  pm_sprite_table_end+1

IRQ_OLD		   = pm_local+0		; 2 bytes
PM_IRQCOUNT	   = pm_local+2
PM_INTERRUPT   = pm_local+3
GHOST_IRQCOUNT = pm_local+4
UPDATE_FLAG    = pm_local+5		; flag 1 = update sprites

PM_SCORE       = pm_local+6		; 2 bytes
PM_STR_BUFFER  = pm_local+8		; 12 bytes

; IRQ location - points to address part of JMP xxxx
IRQ_ADDR = $20A

.code

;------------------------------------------------------------------
; 1. Load chars to consecutive locations in 
; MODE 2 pattern table
;
pm_loadchars:
			ld16 TMP0,PM_CHAR_TAB	   ; character defs
pmdm_loop2: LDY #0
pmdm_loop1: LDA (TMP0),Y
			JSR vdp_write
			INY
			BNE pmdm_loop1			  ; loop 256 times = 32 8byte chars
			RTS
pacman:
pm_drawmaze:
			phx
			phy
			LDA #2					  ; MODE 2
			JSR vdp_set_mode
			LDA #$F0
			JSR vdp_set_base_colors

			JSR vdp_setaddr_pattern_table
			JSR pm_loadchars

			; load chars twice more
			LDA #$08
			STA TMP0
			JSR vdp_setaddr_pattern_table_offset
			JSR pm_loadchars

			LDA #$10
			STA TMP0
			JSR vdp_setaddr_pattern_table_offset
			JSR pm_loadchars

;------------------------------------------------------------------
; 2. Colours - Blue for maze, yellow for pills & dots
pm_loadcols:
			LDA #3
			STA TMP0+1

			LDA VDP_REGS+3	  ;; Color table
			AND #$80			;; just want upper bit
			CLC
			ROR
			ROR
			STA TMP0			; TMP 0 has msb of color table
pmdm_colloop:
			LDY #0
			LDA TMP0
			JSR vdp_set_addr_w

			LDA #$40					; Blue/black
			LDX #28					 ; 28 characters
pmdm_loop4: LDY #8					  ; 8 bytes per char
pmdm_loop3: JSR vdp_write
			DEY
			BNE pmdm_loop3
			DEX
			BNE pmdm_loop4

			LDA #$90					; Yellow/black
			LDX #4					  ; 4 characters
pmdm_loop6: LDY #8					  ; 8 bytes per char
pmdm_loop5: JSR vdp_write
			DEY
			BNE pmdm_loop5
			DEX
			BNE pmdm_loop6
		 
			CLC						 ; Add 2048 to address (8 to hi)
			LDA TMP0
			ADC #$08
			STA TMP0

			DEC TMP0+1				  ; we do the colour load 3 times
			LDA TMP0+1
			BNE pmdm_colloop

;------------------------------------------------------------------
; 3. Load pattern to name table
;	Screen is 32x24 characters
pm_loadnames:
			JSR vdp_setaddr_name_table
			ld16 TMP0, PACMAN_MAZE
			LDX #24
pmdm_loop8: LDY #0 
pmdm_loop7: LDA (TMP0),Y
			JSR vdp_write
			INY
			CPY #32					 ; 32 chars per line
			BNE pmdm_loop7
			add8To16 #32, TMP0
			DEX
			BNE pmdm_loop8
;------------------------------------------------------------------
; 4. Load game map 32x24
;			ld16 TMP2, pm_map		   ; set address of internal map
;			ld16 TMP0, PACMAN_MAP	   ; 
;			LDX #3					  ; 3 * 256
;pmdm_loop10: LDY #0 
;pmdm_loop9: LDA (TMP0),Y
;			STA (TMP2),Y
;			INY
;			BNE pmdm_loop9
;			add8To16 #32, TMP0
;			add8To16 #32, TMP2
;			DEX
;			BNE pmdm_loop10

;------------------------------------------------------------------
; 5. Sprites
; Init and Set sprite type (8x8 unmag)
			JSR vdp_init_sprites
			JSR spr_set_small
			JSR spr_set_mag_off

; Load sprite patterns
			ld16 ZP_TMP0, PM_SPRITES
			STZ ZP_TMP2				; load into P=0,1 ...
@next_pattern:
			JSR vdp_load_sprite_data_from_mem
			CLC
			add8To16 #8,ZP_TMP0		; move data ptr to next pattern
			INC ZP_TMP2				; inrement pattern numner
			LDA ZP_TMP2
			CMP #PM_NUM_SPRITE_PATTERNS
			BNE @next_pattern

; Initialise sprite table
			; Pacman
			LDA #112
			STA PM_ST_SPR1_X
			LDA #144
			STA PM_ST_SPR1_Y
			LDA #0
			STA PM_ST_SPR1_P
			LDA #LIT_YELLOW
			STA PM_ST_SPR1_C

			; Red Ghost
			LDA #96
			STA PM_ST_SPR2_X
			LDA #88
			STA PM_ST_SPR2_Y
			LDA #9
			STA PM_ST_SPR2_P
			LDA #DRK_RED
			STA PM_ST_SPR2_C

			; Green Ghost
			LDA #112
			STA PM_ST_SPR3_X
			LDA #88
			STA PM_ST_SPR3_Y
			LDA #9
			STA PM_ST_SPR3_P
			LDA #LIT_GREEN
			STA PM_ST_SPR3_C

			; Cyan Ghost
			LDA #128
			STA PM_ST_SPR4_X
			LDA #88
			STA PM_ST_SPR4_Y
			LDA #9
			STA PM_ST_SPR4_P
			LDA #CYAN
			STA PM_ST_SPR4_C

			LDA #4
			STA PM_NUMPRITES

; Initialise Positon data
; start at (14,18) = (14+18*32)=590=$24E
			LDA #14
			STA PM_POS_X
			LDA #18
			STA PM_POS_Y
			LDA #$4E
			STA PM_NT_LO
			LDA #$02
			STA PM_NT_HI
			LDA #PM_DIR_NUM_L			  ; facing left
			STA PM_DIR_NUM
			LDA #2
			STA PM_DIR_MASK
			STA pm_input_dir_mask
; Enable sprites
			LDA PM_NUMPRITES		   ; enable sprites
			STA ZP_TMP0				; Pass number of sprites in ZP_TMP0
			JSR vdp_enable_sprites

;------------------------------------------------------------------
; 6. General setup
; write score
			STZ PM_SCORE
			STZ PM_SCORE+1
			JSR pm_draw_score

.if .def(PS2K) || .def(VKEYB)
; init keyboard
			jsr KBINIT
			lda #0
			sta KBD_FLAGS ; use KBD_FLAGS zp var to hold key flags
						  ; 7  6  5  4  3  2  1  0
						  ;			 a  s  d  w
.endif

;------------------------------------------------------------------
; 7. Interrupts
;
; Setup interrupt handler
pmih_save_old:
			LDA IRQ_ADDR
			STA IRQ_OLD
			LDA IRQ_ADDR+1
			STA IRQ_OLD+1

			LDA #$00
			STA PM_IRQCOUNT
			STA GHOST_IRQCOUNT

			LDA #<PM_IRQ
			STA IRQ_ADDR
			LDA #>PM_IRQ
			STA IRQ_ADDR+1

; Enable VDP IRQ output (every 1/60th second)
			LDA VDP_REGS+1		;; data to write is existing Reg1 (was set by MODE command)
			ORA #$20			;; with bit2 set - actually bit 5 if numbered from LSb like sensible chips
			STA VDP_REGS+1
			LDY #$81			;; register to write (1)
			JSR vdp_regwrite

			JSR vdp_getstatus   ;; clear interrupt flag in VDP

; Start allowing interrupts at CPU
			CLI

			STZ pm_game			; start at state 0 - not playing yet
			JSR pm_readmap		; get allowed directions at start position
			STA pm_allowed

;------------------------------------------------------------------
; GAME LOOP
;   -- Busy loop waiting for interrupt to occur
;   -- On Interrupt:
;	  -- Get KBD Input - this sets flags of which keys are currently pressed
;	  -- Read the map and set allowed directions PM can move in
;	  -- Process the key presses into movement
;	  
game_loop:
gl_dogame:
			LDA PM_INTERRUPT		; check interrupt has happened
			BNE gl_get_input
			JMP game_loop

gl_get_input:
			LDA #0
			STA PM_INTERRUPT		; reset interrupt flag

			;-----------------------------------
			; Get input - sets pm_input_dir_mask
			;   - only one of u/d/l/r is set
			;
			JSR pm_get_input_serial
.ifdef KEYB
			JSR pm_get_input_keyboard
.endif
.if .def(PS2K) || .def(VKEYB)
			JSR pm_get_input_ps2k
.endif
			LDA pm_game		; check game state:
			CMP #$00		; 	game not started?
			BEQ game_loop	; 		yes, keep just checking input
			CMP #$FF		; 	quit requested?
			BEQ quit_game	; 		yes, quit

			;------------------------------------------------
			; get allowed directions of movement for PM_NT_LO/HI
			;
			JSR pm_readmap	
			STA pm_allowed	

			;------------------------------------------------
			; check key input against allowed movement directions
			;  - takes allowed input (pm_allowed) 
			;  - and keypress direction (pm_input_dir_mask)
			; writes PM_DIR_NUM & PM_DIR_MASK (direction PM is moving)
			;
			JSR pm_check_input_and_direction

			;------------------------------------------------
			; move pacman position
			;
			JSR move_pacman

			;------------------------------------------------
			; update sprite position and animation
			;
			JSR gl_do_update

			;------------------------------------------------
			; loop
			;
			JMP game_loop

;------------------------------------------------------------------
; Exit
quit_game:
			JSR pm_quit_game
			ply
			plx
			RTS

;==================================================================
; Subroutines
;==================================================================

;------------------------------------------------------------------
; PM_ST_SPR1_X/Y is XY position of 8x8 PM sprite
; But actual square is dependent on position of PM centre
;  +-------+-------+
;  +   ........    +
;  position MOD 8 : 0-3 means it is in left square, 4-7 right
;     Actual position is stored in PM_POS_X/Y
;
gl_do_update:
			JSR get_pm_pos				; Gets sprite character X/Y
			JSR update_pm_nametable_pos	; Updates the POS and NT location

			; check if sprite is exactly in square
			LDA PM_ST_SPR1_X
			AND #%00000111
			BNE gl_update_pm
			LDA PM_ST_SPR1_Y
			AND #%00000111
			BNE gl_update_pm

			; in square exactly
			JSR pm_read_nametable
			CMP #28				 ; 28 = dot
			BEQ gl_is_dot
			CMP #29
			BEQ gl_is_pill
			
			JMP gl_update_pm

gl_is_dot:
			; dot = add 10 to score
			add8To16 #10, PM_SCORE
			JMP gl_update_score
			
gl_is_pill:
			; pill = add 50 to score
			add8To16 #50, PM_SCORE

gl_update_score:
			; display new score
			JSR pm_draw_score

			; write to name table - space
			JSR pm_write_nametable

gl_update_pm:
			JSR pm_update_pm_sprite		; update animation
			JSR pm_update_ghost_sprite

			LDA #1
			STA UPDATE_FLAG      ; tell update routine to update sprites

			RTS

;------------------------------------------------------------------
; Move PM subroutine
; Inputs:
;  - PM_DIR_NUM		current dir PM is moving in 0=L,1=R,2=U,3=D
;  - PM_ST_SPR1_X/Y		sprite top-left pos
; Outputs:
;   - sprite pos
move_pacman:
			LDA PM_IRQCOUNT			; update every N ticks
			AND #$01				; N=2 
			BEQ mp_do_update
			RTS
mp_do_update:
			LDA PM_DIR_NUM
			CMP #PM_DIR_NUM_L
			BEQ mp_move_left
			CMP #PM_DIR_NUM_R
			BEQ mp_move_right
			CMP #PM_DIR_NUM_D
			BEQ mp_move_down
			CMP #PM_DIR_NUM_U
			BEQ mp_move_up
			RTS

mp_move_right:
			JMP pm_move_right
mp_move_left:
			JMP pm_move_left
mp_move_up:
			JMP pm_move_up
mp_move_down:
			JMP pm_move_down


;------------------------------------------------------------------
pm_move_left:
			; if pos is at left of current square then move
			; to next square of pos. Otherwise just move
			LDA PM_ST_SPR1_X
			AND #$07
			BNE pml_decx		 ; not 0 (fully in square) so keep moving

			; check allowed directions
			LDA pm_allowed
			AND #PM_DIR_L_BIT
			BEQ pml_skipx

			; decrement PM pos (absolute)
;			dec16 PM_NT_LO
pml_decx:
			DEC PM_ST_SPR1_X
pml_skipx:
			RTS
pm_move_right:
			; if pos is at far right of current square then move
			; to next square of pos. Otherwise just move
			LDA PM_ST_SPR1_X
			AND #$07
			BNE pml_incx		 ; not in square so keep moving

			; check allowed directions
			LDA pm_allowed
			AND #PM_DIR_R_BIT
			BEQ pml_skipx

			; increment PM pos (absolute)
;			inc16 PM_NT_LO
			INC PM_ST_SPR1_X
			RTS
			; check allowed directions
			LDA pm_allowed
			AND #PM_DIR_R_BIT
			BEQ pml_skipx
pml_incx:
			INC PM_ST_SPR1_X
			RTS

pm_move_up:
			; if pos is at top of current square then move
			; to next square of pos. Otherwise just move
			LDA PM_ST_SPR1_Y
			AND #$07
			BNE pml_decy		 ; not 0 (fully in square) so keep moving

			; check allowed directions
			LDA pm_allowed
			AND #PM_DIR_U_BIT
			BEQ pml_skipy

			; subtract 32 from PM pos (absolute)
;			sub8From16 #32, PM_NT_LO
pml_decy:
			DEC PM_ST_SPR1_Y
pml_skipy:
			RTS
pm_move_down:
			; if pos is at bottom right of current square then move
			; to next square of pos. Otherwise just move
			LDA PM_ST_SPR1_Y
			AND #$07
			BNE pml_incy		 ; not in square so keep moving

			; check allowed directions
			LDA pm_allowed
			AND #PM_DIR_D_BIT
			BEQ pml_skipy

			; add 32 to PM pos (absolute)
;			add8To16 #32, PM_NT_LO
			INC PM_ST_SPR1_Y
			RTS
			LDA pm_allowed
			AND #PM_DIR_D_BIT
			BEQ pml_skipy
pml_incy:
			INC PM_ST_SPR1_Y
			RTS
 
 
;---------------------------------------
; Function get_pm_pos will return pacman x/y character position
; of pacman based on sprite top-left position
;   returns Acc = X, Yreg = Y
;
get_pm_pos:
			LDA PM_ST_SPR1_Y
			CLC
			ADC #4
			LSR
			LSR
			LSR					; divide by 8
			TAY
			LDA PM_ST_SPR1_X
			CLC
			ADC #4
			LSR
			LSR
			LSR					; divide by 8
			RTS
; update nametable position 
;   input : Acc = X, Yreg = Y
;           PM_POS_X/Y that reflects nametable position PM_NT_LO/HI
;   output: Change PM_NT_LO/HI 
;           Change PM_POS_X/Y
;
update_pm_nametable_pos:
			STA TMP0			; Save A/Y
			STY TMP0+1
			TYA
			; if Y position hasn't changed don't recalc Y
			CMP PM_POS_Y
			BEQ upmp_do_x		; NewY == OldY
	upmp_do_y:			
			BCC upmp_do_y_neg	; NewY < OldY
			; Y has increased. Get difference and add 32 for each line
			; note: carry is already set here
			SBC PM_POS_Y		; Acc = NewY - OldY
			TAY					; counter
	@loop:	add8To16 #32, PM_NT_LO
			DEY
			BNE @loop
			BRA upmp_do_x		; finished - go do the X part

	upmp_do_y_neg:				; Y change is negative
			LDA PM_POS_Y
			SEC
			SBC TMP0+1
			TAY
	@loop:	sub8From16 #32, PM_NT_LO
			DEY
			BNE @loop

	upmp_do_x:					; X part
			LDA TMP0
			CMP PM_POS_X
			BEQ upmp_done		; X NewX == OldX

			BCC upmp_do_x_neg	; NewX < OldX
			; X has increased.  Add 32 for each difference
			; note: carry is already set here
			SBC PM_POS_X		; Acc = NewX - OldX
			TAY					; counter
	@loop:	inc16 PM_NT_LO
			DEY
			BNE @loop
			BRA upmp_done

	upmp_do_x_neg:			
			LDA PM_POS_X
			SEC
			SBC TMP0
			TAY
	@loop:	dec16 PM_NT_LO
			DEY
			BNE @loop


	upmp_done:
			LDA TMP0
			STA PM_POS_X
			LDA TMP0+1
			STA PM_POS_Y
			RTS

;---------------------------------------
; Read game map at pacmans's position PM_NT_LO/HI
;
pm_readmap: CLC
			LDA #<PACMAN_MAP
			ADC PM_NT_LO
			STA TMP2
			LDA #>PACMAN_MAP
			ADC PM_NT_HI
			STA TMP2+1
			LDY #0
			LDA (TMP2),Y
			RTS

;---------------------------------------
; read from name table (i.e. screen)
;
pm_read_nametable:
			LDY PM_NT_LO			 ;; Set VRAM address to name table (VDP_REG2 * 0x400) + PM_NT_LO/HI
			LDA VDP_REGS+2
			ASL
			ASL
			CLC
			ADC PM_NT_HI
			JSR vdp_set_addr_r
			LDA VDP_RD_VRAM
			RTS
;---------------------------------------
; write to name table (i.e screen) at pacman's position
;  - will generally be to blank out a pill
;
pm_write_nametable:
			LDY PM_NT_LO			 ;; Set VRAM address to name table (VDP_REG2 * 0x400) + PM_NT_LO/HI
			LDA VDP_REGS+2
			ASL
			ASL
			CLC
			ADC PM_NT_HI
			JSR vdp_set_addr_w
			LDA #0
			STA VDP_WR_VRAM
			RTS

;---------------------------------------
; Get input from ACIA
;
pm_get_input_serial:
			LDA ACIA_STATUS
			AND #ACIA_STATUS_RX_FULL
			BEQ gis_no_dir_input
			LDA ACIA_DATA

			CMP #'q'
			BEQ gip_do_QUIT
gis_check_space:
			CMP #' '
			BEQ gip_do_START
gis_check_wasd:
			CMP #'a'
			BEQ gip_do_LEFT
@check_d:   CMP #'d'
			BEQ gip_do_RIGHT
@check_w:   CMP #'w'
			BEQ gip_do_UP
@check_s:   CMP #'s'
			BEQ gip_do_DOWN
gis_no_dir_input:
			;LDA #0
			;STA pm_input_dir_mask
			RTS

gip_do_QUIT:
			lda #$FF
			sta pm_game
			rts
gip_do_START:
			lda #$01
			sta pm_game
			rts
gip_do_LEFT:
			LDA #PM_DIR_L_BIT
			STA pm_input_dir_mask
			rts
gip_do_RIGHT:
			LDA #PM_DIR_R_BIT
			STA pm_input_dir_mask
			rts
gip_do_UP:
			LDA #PM_DIR_U_BIT
			STA pm_input_dir_mask
			rts
gip_do_DOWN:
			LDA #PM_DIR_D_BIT
			STA pm_input_dir_mask
			rts

;---------------------------------------
; Get input PC Keyboard
;
.if .def(PS2K) || .def(VKEYB)
pm_get_input_ps2k:
			jsr KBSCAN_GAME
			bcc gip_done
			ldx #0				  ; 0 in X means this is a make code
			lda KBD_CHAR
			cmp #SC_SPECIAL		 ; check for a break code
			bne gip_skip_set_breakcode

			; dont care about release
			rts
			;lda KBD_SPECIAL		 ; get break code
			;beq gip_done
			;ldx #1				  ; 1 in X means this is a break code
		
gip_skip_set_breakcode:
			cmp #SC_A
			beq gip_do_LEFT
			cmp #SC_RAW_LEFT_ARROW
			beq gip_do_LEFT
			;cmp #SC_NC_LEFT_ARROW
			;beq gip_do_LEFT

			cmp #SC_D
			beq gip_do_RIGHT
			cmp #SC_RAW_RIGHT_ARROW
			beq gip_do_RIGHT
			;cmp #SC_NC_RIGHT_ARROW
			;beq gip_do_RIGHT

			cmp #SC_W
			beq gip_do_UP
			cmp #SC_RAW_UP_ARROW
			beq gip_do_UP
			;cmp #SC_NC_UP_ARROW
			;beq gip_do_UP

			cmp #SC_S
			beq gip_do_DOWN
			cmp #SC_RAW_DOWN_ARROW
			beq gip_do_DOWN
			;cmp #SC_NC_DOWN_ARROW
			;beq gip_do_DOWN

			cmp #SC_SPC
			beq gip_do_START
			cmp #SC_Q
			beq gip_do_QUIT

gip_done:
			;LDA #0
			;STA pm_input_dir_mask
			rts
.endif

;---------------------------------------
; pm_check_input_and_direction
; Input: 
;  - pm_allowed
;  - pm_input_dir_mask
; Output:
;  - PM_DIR_NUM - dir in terms of 0,1,2,3
;  - PM_DIR_MASK   - dir as a move bitmask
;
pm_check_input_and_direction:
			LDA pm_input_dir_mask
			CMP PM_DIR_MASK
			BNE pcid_do_check		; if input has changed, check
	pcid_done:
			RTS

	pcid_do_check:
	
	; only check when exactly in square if turning
		
			LDA PM_DIR_MASK
			AND #$0C				; U/D
			BNE curr_move_is_ud

	curr_move_is_lr:
			LDA pm_input_dir_mask
			AND #$03					
			BNE pcid_filter_allowed 	; new dir is also L/R

	; change dir from L/R to U/D - must be in square (only need to check L/R)
	check_in_square_horiz:
			LDA PM_ST_SPR1_X	
			AND #7
			BEQ pcid_filter_allowed		; in centre, go check all possibilities
		; don't allow change of direction
			LDA pm_input_dir_mask
			AND #$03
			STA pm_input_dir_mask
			BRA pcid_filter_allowed

	curr_move_is_ud:
			LDA pm_input_dir_mask
			AND #$0C
			BNE pcid_filter_allowed	; new dir is also U/D

	; change dir from U/D to L/R - must be in square (only need to check U/D)
	check_in_square_vert:
			LDA PM_ST_SPR1_Y
			AND #7
			BEQ pcid_filter_allowed		; in centre, go check all possibilities
		; don't allow change of direction
			LDA pm_input_dir_mask
			AND #$0C
			STA pm_input_dir_mask

	; now check allowed movement directions
	pcid_filter_allowed:
			LDA pm_input_dir_mask
			AND pm_allowed			; mask of allowed directions
			STA PM_DIR_MASK			

	; convert mask to a number for sprite direction movement
			CMP #PM_DIR_L_BIT
			BNE @next1
			LDX #PM_DIR_NUM_L
			STX PM_DIR_NUM
			RTS
		@next1:
			CMP #PM_DIR_R_BIT
			BNE @next2
			LDX #PM_DIR_NUM_R
			STX PM_DIR_NUM
			RTS
		@next2:
			CMP #PM_DIR_D_BIT
			BNE @next3
			LDX #PM_DIR_NUM_D
			STX PM_DIR_NUM
			RTS
		@next3:
			CMP #PM_DIR_U_BIT
			BNE @done
			LDX #PM_DIR_NUM_U
			STX PM_DIR_NUM
		@done:
			RTS

;------------------------------------------------------------------
; Quit
pm_quit_game:
			ld16 R0,quit_message
			JSR acia_puts
; restore interrupt vector 
			LDA IRQ_OLD
			STA IRQ_ADDR
			LDA IRQ_OLD+1
			STA IRQ_ADDR+1
; disable interrupts at CPU
			SEI

; disable interrupts from VDP
			LDA VDP_REGS+1		;; data to write is existing Reg1
			AND #$DF			;; unset interrupt bit
			STA VDP_REGS+1
			LDY #$81			;; register to write (1)
			JSR vdp_regwrite

			JSR vdp_getstatus   ;; clear interrupt flag in VDP

			RTS

;------------------------------------------------------------------
; VDP IRQ Handler
PM_IRQ:		PHP						; save status flags (so BCD is correct)
			PHA
			JSR pm_draw_sprites		; Write current sprite info to Sprite Atrr table
			DEC PM_IRQCOUNT			;; count--
			DEC PM_INTERRUPT		;; make interrupt flag != 0
			INC GHOST_IRQCOUNT

@skip:		JSR vdp_getstatus		;; read VDP status to reenable the VDP interrupt
			PLA 
			PLP
			RTI

;------------------------------------------------------------------
; draw sprites from table
;   -- draws all enabled sprites if update-flag is set
;   -- by writing to the Sprite Attribute table
;
pm_draw_sprites:
			LDA UPDATE_FLAG
			BNE pm_do_draw
			RTS
pm_do_draw:
			phx
			phy
			LDA PM_NUMPRITES			
			BEQ pds_done
			ASL						; 4 bytes per sprite
			ASL
			TAX						; X has size of table

			LDY VDP_SAB				; set vdp up to write to Sprite Attrib Base
			LDA VDP_SAB+1
			JSR vdp_set_addr_w
			LDY #0					; index into table
pds_loop1:
			LDA PM_ST_SPR1_Y,Y		; read byte from table
			JSR vdp_write			; wrie to VDP
			INY
			DEX
			BNE pds_loop1
pds_done:
			STZ UPDATE_FLAG
			ply
			plx
			RTS
			

;------------------------------------------------------------------
; Draw score to screen
pm_draw_score:
			; put score into R1,R+1
			LDA PM_SCORE
			STA R1
			LDA PM_SCORE+1
			STA R1+1
			; convert to decimal
			JSR BINBCD16
			ld16 R0,PM_STR_BUFFER
			JSR BCD4BYTE2STR
			
			LDA #27					; X
			LDY #9					; Y
			JSR vdp_set_pos
			JSR vdp_write_text  
			RTS
			
;------------------------------------------------------------------
; update the PM sprite animation
;   -- PM_IRQCOUNT starts at 0, decremented every 1/50 sec (20ms)
;   -- every 8*20=160ms the sprite pattern is changed 
pm_update_pm_sprite:
			LDA PM_IRQCOUNT
			AND #%00011000			; change sprite from 0-3 every 8th tick
			LSR
			LSR
			LSR						; value is now 0-3
			; add 4*PM_DIR_NUM
			STA TMP0
			LDA PM_DIR_NUM			; direction 
			ASL
			ASL
			CLC
			ADC TMP0				; add 4*PM_DIR_NUM to tick number
			; lookup sprite number
			TAY
			LDA PM_SPR_INDEX,Y
			; store in pattern
			STA PM_ST_SPR1_P
			RTS

;------------------------------------------------------------------
; update ghost animation - not dependent on pos of PM for now!
;   -- ghost sprite toggles between 9 and 10
;   -- GHOST_IRQCOUNT is incremented every 1/50 sec (20ms)
pm_update_ghost_sprite:
			LDA GHOST_IRQCOUNT
			AND #%00010000			; every 16*20ms = 320ms
			LSR
			LSR
			LSR
			LSR						; now 0-1
			CLC
			ADC #9					; now 9-10
pugs_save:
			STA PM_ST_SPR2_P
			STA PM_ST_SPR3_P
			STA PM_ST_SPR4_P
pugs_done:			
			RTS

quit_message:
	.byte "Goodbye!",$0d,$0a,$00

.include "pm_char_set.inc65"
.include "pm_char_map.inc65"
.include "pm_sprites.inc65"
.include "pm_map.inc65"
