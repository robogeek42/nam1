; vim: ts=4 sw=4
; Pong 

.setcpu "65C02"

.include "macros.inc65"
.include "zeropage.inc65"
.include "acia.inc65"
.include "io.inc65"
.include "string.inc65"
.include "video.inc65"
.include "video_common.inc65"
.include "video_registers.inc65"
.include "sprite.inc65"
.include "bcd.inc65"
.include "kbdvia.inc65"
.include "sound.inc65"
.include "colors.inc65"
.include "scancodes.inc65"
.include "pckybd.inc65"

.export breakout
.export BOUT_IRQ

; breakout vars in basic program area
bout_vars = $7000

pp_ballx	= bout_vars+0
pp_bally	= bout_vars+1
pp_ballxv	= bout_vars+4; ball velocity in X
pp_ballyv	= bout_vars+5; ball velocity in Y
pp_game		= bout_vars+8; Game state. 0=not started, 1=playing, FF=quit, FE=win message
IRQ_COUNT	= bout_vars+9
IRQ_OLD		= bout_vars+10 ; 2 bytes
bo_interval	= bout_vars+12  ; number of 1/60sec intervals between updating screen
bo_c0_vol	= bout_vars+20;
strbuf		= bout_vars+21;

; IRQ location - points to address part of JMP xxxx
IRQ_ADDR = $20A

.bss
score_buffer:
	.res 4,0

.code

breakout:
; sound channels all off
.ifdef SOUND
		JSR snd_all_off
.endif

; set mode
		LDA #3					; Graphics II mode
		JSR vdp_set_mode
		; Set main play area colors
		LDA #FG_WHITE
		ORA #BG_DRK_BLUE
		JSR vdp_load_flat_colors
		; set corder color
		LDA #FG_WHITE
		ORA #BG_LIT_GREEN
		LDY #$87
		JSR vdp_regwrite

; Draw board
        JSR draw_board

;; initialise game variables
		STZ pp_game


;---------------------------------------
.if .def(PS2K) || .def(VKEYB)
; init keyboard
		jsr KBINIT
		lda #0
		sta KBD_FLAGS ; use KBD_FLAGS zp var to hold key flags
					  ; 7  6  5  4  3  2  1  0
					  ;				      L  R
					  ;				      z  x
.endif

;=======================================
; Setup interrupt handler
pih_save_old:
		LDA IRQ_ADDR
		STA IRQ_OLD
		LDA IRQ_ADDR+1
		STA IRQ_OLD+1

		LDA #$01
		STA bo_interval
		STA IRQ_COUNT

pih_setup_new:
		LDA #<BOUT_IRQ
		STA IRQ_ADDR
		LDA #>BOUT_IRQ
		STA IRQ_ADDR+1

; Enable VDP IRQ output (every 1/60th second)
pih_enable_vdp_irq:
		LDA VDP_REGS+1	  ;; data to write is existing Reg1 (was set by MODE command)
		ORA #$20			;; with bit2 set - actually bit 5 if numbered from LSb like sensible chips
		STA VDP_REGS+1
		LDY #$81			;; register to write (1)
		JSR vdp_regwrite

		JSR vdp_getstatus   ;; clear interrupt flag in VDP

; Start allowing interrupts at CPU
		CLI

;=======================================
; Game loop
game_loop:

		JSR get_input_serial

.if .def(PS2K) || .def(VKEYB)
		JSR get_input_ps2k
.endif

check_irq_count:
		LDA IRQ_COUNT
		BNE gl_skip_update
		LDA bo_interval		 ;; start counting again (bo_interval * 1/60th)
		STA IRQ_COUNT

		JSR sound_vol       ; reduce sound vol after a note

.if .def(PS2K) || .def(VKEYB)
		JSR check_key_flags
.endif

		JSR draw_paddle

		LDA pp_game		; check game state:
		CMP #$00		; 	game not started?
		BEQ game_loop	; 		yes, keep just checking input and drawing paddles
		CMP #$02		;   pause state?
		BEQ game_loop
		CMP #$FF		; 	quit requested?
		BNE gl_dogame	; 		no, then continue
		JMP quit_game	; 		yes, quit
gl_dogame:
		JSR move_ball
		JSR draw_ball
		JSR check_game
		;JSR draw_score

gl_skip_update:
        JMP game_loop

;---------------------------------------
; Interrupt handler
BOUT_IRQ:
		PHA

		JSR vdp_getstatus		   ;; read VDP status to reenable the VDP interrupt
		LDA IRQ_COUNT			   ;; if count >0
		BEQ @skip
		DEC IRQ_COUNT			   ;; count--
@skip:
		PLA
		RTI
;---------------------------------------


;---------------------------------------
; Get input from ACIA
get_input_serial:
		LDA ACIA_STATUS
		AND #ACIA_STATUS_RX_FULL
		BEQ gi_done
		LDA ACIA_DATA

		CMP #'z'
        BEQ gi_move_left
		CMP #'x'
        BEQ gi_move_right
		CMP #'q'
        BEQ gi_do_QUIT

gi_check_space:
		CMP #' '
        BEQ gi_do_START

gi_done:
		RTS

gi_do_QUIT:
		LDA #$FF
		STA pp_game
		rts
gi_do_START:
		LDA #$01
		STA pp_game
		rts

gi_move_left:
		RTS
gi_move_right:
		RTS
;---------------------------------------
.if .def(PS2K) || .def(VKEYB)
check_key_flags:
		lda #1
		bit KBD_FLAGS
		beq @next1
        jsr gi_move_right
	@next1:
		lda #2
		bit KBD_FLAGS
        beq @over
        jsr gi_move_left
	@over:
		rts

;-----------------------------------------------------
; This sets the KBD_FLAGS variable as above
;
get_input_ps2k:
		jsr KBSCAN_GAME
		bcc gip_done
		
		ldx #0				  ; 0 in X means this is a make code
		lda KBD_CHAR
		cmp #SC_SPECIAL		 ; check for a break code
		bne gip_skip_set_breakcode

		lda KBD_SPECIAL		 ; get break code
		;beq gip_done
		ldx #1				  ; 1 in X means this is a break code
		
gip_skip_set_breakcode:
		cmp #SC_Z
		beq gip_do_LEFT
		cmp #SC_X
		beq gip_do_RIGHT

		cmp #SC_S
		beq gi_do_START
		cmp #SC_SPC
		beq gi_do_START
		cmp #SC_Q
		beq gi_do_QUIT
		
gip_done:
		rts

gip_do_RIGHT:
		cpx #0
		beq @do_make
		RMB0 KBD_FLAGS	  ; key unpressed - unset bit 0
		rts
  @do_make:
		SMB0 KBD_FLAGS	  ; key was pressed - set bit 0
		rts

gip_do_LEFT:
		cpx #0
		beq @do_make
		RMB1 KBD_FLAGS
		rts
  @do_make:
		SMB1 KBD_FLAGS
		rts

.endif

;---------------------------------------
; Check game conditions
; Check ball position - if going off left, inc R score
check_game:
		RTS

;---------------------------------------
; Draw ball
draw_ball:
		RTS

;--------------------------------------------------
; Check ball position and change speed as necessary
; Move the ball according to current speed
;
move_ball:
		RTS

;---------------------------------------
; Draw paddle
draw_paddle:
		RTS



;---------------------------------------
;
quit_game:
		ld16 R0,quit_message
		JSR acia_puts
; restore interrupt vector 
pih_restore_irq:
		LDA IRQ_OLD
		STA IRQ_ADDR
		LDA IRQ_OLD+1
		STA IRQ_ADDR+1
; disable interrupts at CPU
		SEI

; disable interrupts from VDP
		LDA VDP_REGS+1	  ;; data to write is existing Reg1
		AND #$DF			;; unset interrupt bit
		STA VDP_REGS+1
		LDY #$81			;; register to write (1)
		JSR vdp_regwrite

		JSR vdp_getstatus   ;; clear interrupt flag in VDP

.ifdef SOUND
		; stop any sounds
		JSR snd_all_off
.endif
.if .def(PS2K) || .def(VKEYB)
		; reenable typematic repeat
		jsr KBTMON
.endif
		LDA #0
		JSR vdp_set_mode
		RTS

;----------------------------------------------------------------------
; Draw board
;
draw_board:
		RTS

;----------------------------------------------------------------------
; Sound
;
.ifdef SOUND
sound_vol:
		LDA pp_c0_vol
		CMP #$0F
		BCS @over
		INC pp_c0_vol
		LDA #%10010000 ; c0 vol
		ORA pp_c0_vol
		JSR snd_write
@over:
		RTS
sound_ping:
		; Set frequency to %0001111111 = 127 -> 3.6864MHz/32*127 = 907Hz
		LDA #%10001111  ; Freq Channel 1 (of 3)
		JSR snd_write
		LDA #%00000111  ; Freq DDDDDD 
		JSR snd_write
		LDA #%10010000 ; c0 vol = full (0)
		JSR snd_write
		STZ pp_c0_vol
		RTS
sound_pong:
		; Set frequency to %0100000110 = 262 -> 3.6864MHz/32*262 ~= 440Hz
		LDA #%10000110  ; Freq Channel 1 (of 3)
		JSR snd_write
		LDA #%00010000  ; Freq DDDDDD 
		JSR snd_write
		LDA #%10010000 ; c0 vol = full (0)
		JSR snd_write
		STZ pp_c0_vol
		RTS
sound_score:
		RTS
.else
sound_vol:
sound_ping:
sound_pong:
sound_score:
		RTS
.endif


quit_message:
	.byte "Goodbye!",$0d,$0a,$00
