.setcpu "65C02"

.include "basic.asm"
.include "zeropage.inc65"
.include "io.inc65"
.include "acia.inc65"
.include "string.inc65"
.include "macros.inc65"
.include "print_util.inc65"
.include "video.inc65"
.include "video_common.inc65"
.include "video_registers.inc65"
;.include "video_test.inc65"

IRQ_vec	= VEC_SV+2		; IRQ code vector
NMI_vec	= IRQ_vec+$0A	; NMI code vector

.segment "VECTORS"

                .word   NMI_vec
				.word   RES_vec
				.word   IRQ_vec

.bss
;-----------------------------------------------------
; buffer for monitor
;-----------------------------------------------------
                BUFFER_LENGTH = 80
buffer:         .res BUFFER_LENGTH+1, 0


.code

RES_vec:
main:           CLD   		; Clear decimal bit
				LDX #$ff	; Reset stack
                TXS

				; set up vectors and interrupt code, copy them to page 3
				LDY	#END_CODE-LAB_vec	; set index/count
LAB_stlp:
				LDA	LAB_vec-1,Y		; get byte from interrupt code
				STA	VEC_IN-1,Y		; save to RAM
				DEY					; decrement index/count
				BNE	LAB_stlp		; loop if more to do

                ; initialise ACIA serial comms
                JSR acia_init

                ; display welcome message in the Serial Console
                ld16 R0, msg_welcome
                JSR acia_puts

                ; Setup video with Mode 0
                LDA #0
                JSR vdp_set_mode
				
                ; display welcome message on video screen
                ld16 R0, msg_welcome
                JSR vdp_write_text

                ; clear address used for 'm' memory dump command
                LDA #0
                STA RES
                STA RES+1

; ---------------------------------------------------------
; -- Command loop
                ; display prompt 
loop:           ld16 R0, prompt
                JSR acia_puts
                ; read input line into a buffer
                ld16 R0, buffer
                LDA #BUFFER_LENGTH
                JSR acia_gets
                LDA buffer

                ; m = print memory address
@cmd_m:         cmp #'m'
                bne @cmd_w
                jsr cmd_memory
                jmp loop

                ; w = write data to adrress
@cmd_w:         cmp #'w'
                bne @cmd_j
                jsr cmd_write
                jmp loop
                
                ; j = jump to address
@cmd_j:         cmp #'j'
                bne @cmd_b
                jsr cmd_jump
                jmp loop

@cmd_b:         cmp #'b'
                bne @cmd_h
				jsr cmd_basic
                jmp loop

                ; h = print help
@cmd_h:         cmp #'h'
                bne @cmd_empty
                ld16 R0, msg_help
                jsr acia_puts
                jmp loop

                ; check for empty line - display prompt again
@cmd_empty:     cmp #$00
                beq loop

                ; (fall through - unknown command)
@cmd_unknown:   ld16 R0, msg_unknown
                jsr acia_puts
                jmp loop

; ---------------------------------------------------------
; -- Strings 
prompt:     .byte "nam-mon-> ", $00
assign_arrow:   .byte " <- ", $00
msg_welcome:    .byte "NAM-1 80K", $0d, $0a,"VDP Graphics",$0d,$0a, $00
msg_unknown:    .byte "Unknown command", $0d, $0a, $00
msg_help:   .byte "m <address>",$0d,$0a,"j <address>",$0d,$0a,"w <address> <byte>",$0d,$0a,"b - basic",$0d,$0a,$00
msg_error:  .byte "Error", $0d, $0a, $00
;msg_vdp_welcome:  .byte "Assif 6502 & EhBasic", $0d, $0a, $00

; ---------------------------------------------------------
; -- execute commands
; Display a range of memory as hex numbers and characters
; m <start-address>
cmd_m_error:    ld16 R0, msg_error
                jsr acia_puts
                rts

cmd_memory: ; Check if only "m" or "m " was entered - address unchanged
                lda buffer + 1
                beq print_address
                lda buffer + 2
                beq print_address

                ; "m" and a not 4 digit address is a error
                lda buffer + 3
                beq cmd_m_error
                lda buffer + 4
                beq cmd_m_error
                lda buffer + 5
                beq cmd_m_error

                ; read the address
                ld16 R0, buffer + 2
                jsr scan_hex16
print_address:  jsr print_memory16
                RTS

; Write a byte to memory
; w <address> <byte>
cmd_write:      ld16 R0, buffer + 2
                jsr scan_hex16

@print_address: ld16 R0, buffer
                lda RES + 1
                jsr fmt_hex_string
                ld16 R0, buffer + 2
                lda RES
                jsr fmt_hex_string
                ld16 R0, buffer
                jsr acia_puts

                lda #':'
                jsr acia_putc

@read_and_print_byte: ld16 R0, buffer + 7
                jsr scan_hex
                tay
                ld16 R0, buffer
                tya
                jsr fmt_hex_string
                jsr acia_puts
                jsr acia_put_newline
                tya

@store_value:   ldy #0
                sta (RES),y
                rts

; Jump to address
; j <address>
cmd_jump:         ld16 R0, buffer + 2
                jsr scan_hex16

@print_address: lda #'*'
                jsr acia_putc
                ld16 R0, buffer
                lda RES + 1
                jsr fmt_hex_string
                ld16 R0, buffer + 2
                lda RES
                jsr fmt_hex_string
                ld16 R0, buffer
                jsr acia_puts
                jsr acia_put_newline

@jump:          jmp (RES)

;-----------------------------------------------------
; run Basic - b[cw]
;
cmd_basic:		
				; set JMP address for Cold boot (default)
				LDA #<LAB_COLD
				STA TMP0
				LDA #>LAB_COLD
				STA TMP0+1
				; setup read from input string
				LDA buffer+1
				CMP #'w'
				BNE @boot_basic
				LDA #<LAB_WARM
				STA TMP0
				LDA #>LAB_WARM
				STA TMP0+1
@boot_basic:	JMP (TMP0)

;-----------------------------------------------------
; BASIC linkage
;  - ROM code from LAB_vec to END_CODE will be copied to RAM $0300
;  - then there will be space for the Basic input buffer
;-----------------------------------------------------
;
; vector tables

LAB_vec:
	.word	ACIAin		; byte in from ACIA
	.word	CHARout		; byte out to ACIA and video
	.word	LOAD		; load vector for EhBASIC
	.word	SAVE		; save vector for EhBASIC

; EhBASIC IRQ support

IRQ_CODE
	PHA				; save A
	LDA	IrqBase		; get the IRQ flag byte
	LSR				; shift the set b7 to b6, and on down ...
	ORA	IrqBase		; OR the original back in
	STA	IrqBase		; save the new IRQ flag byte
	PLA				; restore A
	RTI

; EhBASIC NMI support

NMI_CODE
	PHA				; save A
	LDA	NmiBase		; get the NMI flag byte
	LSR				; shift the set b7 to b6, and on down ...
	ORA	NmiBase		; OR the original back in
	STA	NmiBase		; save the new NMI flag byte
	PLA				; restore A
	RTI

END_CODE

CHARout:
	JSR ACIAout
	JSR vdp_write_char
	RTS

ACIAout:
	PHA				; A contains char to print
@wait_txd_empty:
	LDA ACIA_STATUS
    AND #ACIA_STATUS_TX_EMPTY
    BEQ @wait_txd_empty
	PLA				; ready to output, restore A
	STA ACIA_DATA	; and output
    RTS

ACIAin:
	LDA	ACIA_STATUS
	AND #ACIA_STATUS_RX_FULL
	BEQ	@nobyw		; branch if no byte waiting
	LDA	ACIA_DATA
	AND	#$7F			; clear high bit
	SEC			  		; flag byte received
	RTS
@nobyw
	CLC				; flag no byte received
    RTS

LOAD:
	RTS
SAVE:
	RTS

DObackspace:
	PHA
	JSR ANSI_BKSP
	PLA
	JSR vdp_backspace
	RTS
	
ANSI_BKSP:
	  ; output ANSI "Cursor back"
	  lda #$1b
	  jsr ACIAout
	  lda #'['
	  jsr ACIAout
	  lda #'D'
	  jsr ACIAout
	  lda #$1b
	  jsr ACIAout
	  lda #'['
	  jsr ACIAout
	  lda #'K'
	  jsr ACIAout
	  RTS
