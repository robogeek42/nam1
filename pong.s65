; Pong 

.setcpu "65C02"

.include "macros.inc65"
.include "zeropage.inc65"
.include "acia.inc65"
.include "io.inc65"
.include "string.inc65"
.include "video.inc65"
.include "video_common.inc65"
.include "video_registers.inc65"
.include "sprite.inc65"
.include "bcd.inc65"
.include "kbdvia.inc65"

.export pong
.export PONG_IRQ

; pong vars in basic program area
pong_vars = $7000
pp_ballx  = pong_vars+0
pp_bally  = pong_vars+1
pp_batly  = pong_vars+2
pp_batry  = pong_vars+3
pp_ballxv = pong_vars+4; ball velocity in X
pp_ballyv = pong_vars+5; ball velocity in Y
pp_scorel = pong_vars+6
pp_scorer = pong_vars+7
pp_game   = pong_vars+8; Game state. 0=not started, 1=playing, FF=quit
;pp_kbdrow = pong_vars+9;
;pp_kbdcol = pong_vars+10;
IRQ_COUNT = pong_vars+9
IRQ_OLD   = pong_vars+10 ; 2 bytes
pp_interval = pong_vars+12  ; number of 1/60sec intervals between updating screen

pp_bsx_pos = pong_vars+15      ; positive value of current ball speed in x
pp_bsy_pos = pong_vars+16      ; positive value of current ball speed in x
pp_bsx_neg = pong_vars+17      ; negative value of current ball speed in y
pp_bsy_neg = pong_vars+18      ; negative value of current ball speed in y

strbuf = pong_vars + 20;

BALLSPEEDX = $02            ; starting ball speeds
BALLSPEEDXNEG = $FE
BALLSPEEDY = $02
BALLSPEEDYNEG = $FE

BATSPEED  = 4

BATL_POS = 16
BATR_POS = 238

; IRQ location - points to address part of JMP xxxx
IRQ_ADDR = $20A

.bss
score_buffer:
	.res 4,0

.code

; Setup sprites for ball and bats
pp_sprite_pattern_start:
bat_left_sprite_top:
	.byte $40,$E0,$E0,$E0,$E0,$E0,$E0,$E0
bat_left_sprite_bot:
	.byte $E0,$E0,$E0,$E0,$E0,$E0,$E0,$40
bat_right_sprite_top:
	.byte $02,$07,$07,$07,$07,$07,$07,$07
bat_right_sprite_bot:
	.byte $07,$07,$07,$07,$07,$07,$07,$02
ball_sprite:
	.byte $3C,$7E,$FF,$FF,$FF,$FF,$7E,$3C
pp_char_pattern_start:
dot_line_char:
	.byte $00,$01,$01,$00,$00,$01,$01,$00
	.byte $00,$80,$80,$00,$00,$80,$80,$00

pong:
; set mode
		LDA #1					; Graphics I mode
		JSR vdp_set_mode
		LDA #$F4				; white on black
		JSR vdp_load_flat_colors
		LDA #$F2				; white on green (background)
		LDY #$87
		JSR vdp_regwrite

; Init and Set sprite type (8x8 unmag)
		JSR vdp_init_sprites
		JSR spr_set_small
		JSR spr_set_mag_off
		LDA #5					; enable 5 sprites
		STA ZP_TMP0				; Pass number of sprites in ZP_TMP0
		JSR vdp_enable_sprites

; Load patterns
		ld16 ZP_TMP0, pp_sprite_pattern_start
		STZ ZP_TMP2				; load into P=0,1 ...
@next_pattern:
		JSR vdp_load_sprite_data_from_mem
		CLC
		add8To16 #8,ZP_TMP0		; move data ptr to next pattern
		INC ZP_TMP2				; inrement pattern numner
		LDA ZP_TMP2
		CMP #5
		BNE @next_pattern

; set sprite pattern, position, colour and early bit
		LDX #0					; X is sprite number (S)
		LDY ZP_VDP_SAB			; set address of Sprite Attribute table
		LDA ZP_VDP_SAB+1
		JSR vdp_set_addr_w
		LDY #0					; most fields are initially 0
		LDA #$0F				; Colour white / no early bit set
@next_sprite:
		STY VDP_WR_VRAM			; Pos X
.ifdef FASTCPU
        NOP
        NOP
        NOP
        NOP
        NOP
.endif
        NOP
        NOP
		STY VDP_WR_VRAM			; Pos Y
.ifdef FASTCPU
        NOP
        NOP
        NOP
        NOP
        NOP
.endif
        NOP
        NOP
		STX VDP_WR_VRAM			; Pattern
.ifdef FASTCPU
        NOP
        NOP
        NOP
        NOP
        NOP
.endif
        NOP
        NOP
		STA VDP_WR_VRAM			; Colour
.ifdef FASTCPU
        NOP
        NOP
        NOP
        NOP
        NOP
.endif
		INX
		CPX #5
		BNE @next_sprite

; disable ball sprite for now
		JSR disable_ball

; set patterns 0&1 to be dots for central line
		ld16 ZP_TMP0, dot_line_char
		JSR vdp_setaddr_pattern_table
		LDY #0
@load_char:
		LDA (ZP_TMP0),Y
        JSR vdp_write
		INY
		CPY #16
		BNE @load_char
		
; Draw board & Score
; Central dotted line
		LDX #24				; height mode 1
        LDA VDP_REGS+2      ; Name table
		ASL
		ASL
		STA ZP_TMP1
		LDA #$0F			; start at position 15
		STA ZP_TMP0
@loop1:
		LDY ZP_TMP0			; set vram write addr
		LDA ZP_TMP1
		JSR vdp_set_addr_w
		LDA #0				; write 2 chars to split centre
        JSR vdp_write
		LDA #1
        NOP
        JSR vdp_write
		
		add8To16 #$20, ZP_TMP0 ; add screen width
		DEX
		BNE @loop1

;; initialise game variables
		LDA #96-8
		STA pp_batly
		STA pp_batry
		STZ pp_scorel
		STZ pp_scorer
		LDA #60-4
		STA pp_bally
		LDA #80-4
		STA pp_ballx
		STZ pp_game

        LDA #BALLSPEEDX
        STA pp_bsx_pos
        STA pp_ballyv       ; current ball speed
        LDA #BALLSPEEDY
        STA pp_bsy_pos
        STA pp_ballxv       ; current ball speed
        LDA #BALLSPEEDXNEG
        STA pp_bsx_neg
        LDA #BALLSPEEDYNEG
        STA pp_bsy_neg

		JSR draw_score

;=======================================
; Setup interrupt handler
pih_save_old:
        LDA IRQ_ADDR
        STA IRQ_OLD
        LDA IRQ_ADDR+1
        STA IRQ_OLD+1

        LDA #$01
        STA pp_interval
        STA IRQ_COUNT

pih_setup_new:
        LDA #<PONG_IRQ
        STA IRQ_ADDR
        LDA #>PONG_IRQ
        STA IRQ_ADDR+1

; Enable VDP IRQ output (every 1/60th second)
pih_enable_vdp_irq:
        LDA VDP_REGS+1      ;; data to write is existing Reg1 (was set by MODE command)
        ORA #$20            ;; with bit2 set - actually bit 5 if numbered from LSb like sensible chips
        STA VDP_REGS+1
        LDY #$81            ;; register to write (1)
        JSR vdp_regwrite

        JSR vdp_getstatus   ;; clear interrupt flag in VDP

; Start allowing interrupts at CPU
        CLI

;=======================================
; Game loop
game_loop:

        JSR get_input_serial

check_irq_count:
        LDA IRQ_COUNT
        BNE gl_skip_update
        ;ld16 R0,irq_message
		;JSR acia_puts
        LDA pp_interval                 ;; start counting again (pp_interval * 1/60th)
        STA IRQ_COUNT

.if KEYB
        JSR get_input_keyboard
.endif
 
		JSR draw_paddles

		LDA pp_game		; check game state:
		CMP #$00		; 	game not started?
		BEQ game_loop	; 		yes, keep just checking input and drawing paddles
		CMP #$FF		; 	quit requested?
		BNE gl_dogame	; 		no, then continue
		JMP quit_game	; 		yes, quit

gl_dogame:
		JSR move_ball
		JSR draw_ball
		JSR check_game
		JSR draw_score
		;JSR delay

gl_skip_update:
		JMP game_loop

;---------------------------------------
; Get input from ACIA
get_input_serial:

		LDA ACIA_STATUS
		AND #ACIA_STATUS_RX_FULL
        BEQ gi_done
		LDA ACIA_DATA
gi_got_key:
;		CMP #'a'
;		BEQ gi_movelup
;		CMP #'z'
;		BEQ gi_moveldown
;		CMP #';'
;		BEQ gi_moverup
;		CMP #'.'
		BEQ gi_moverdown
		CMP #'q'
		BNE gi_check_s
		LDA #$FF
		STA pp_game
gi_check_s:
		CMP #'s'
        BNE gi_check_minus
		LDA #$01
		STA pp_game
        JMP gi_done
gi_check_minus:
        CMP #'-'
        BNE gi_check_plus
        DEC pp_interval
        JSR gi_print_interval

gi_check_plus:
        CMP #'+'
        BNE gi_done
        INC pp_interval

gi_print_interval:
        ld16 R0,strbuf
        LDA pp_interval
        JSR fmt_hex_string
        JSR acia_puts
        JSR acia_put_newline
        
gi_done:
		RTS

gi_movelup:
		LDA pp_batly
		CMP #BATSPEED			; top=0+BATSPEED
		BCC gi_done				; A < top
		SEC
		LDA pp_batly
		SBC #BATSPEED
		STA pp_batly
		RTS
gi_moveldown:
		LDA pp_batly
		CMP #193-16-BATSPEED	; bot=193-BATSIZE-BATSPEED
		BCS gi_done				; A >= bot
		CLC
		LDA pp_batly
		ADC #BATSPEED
		STA pp_batly
		RTS
gi_moverup:
		LDA pp_batry
		CMP #BATSPEED			; top=0+BATSPEED
		BCC gi_done				; A < top
		SEC
		LDA pp_batry
		SBC #BATSPEED
		STA pp_batry
		RTS
gi_moverdown:
		LDA pp_batry
		CMP #193-16-BATSPEED	; bot=193-BATSIZE-BATSPEED
		BCS gi_done				; A >= bot
		CLC
		LDA pp_batry
		ADC #BATSPEED
		STA pp_batry
		RTS

.if KEYB
;---------------------------------------
; Get input from KEYBOARD
get_input_keyboard:
        JSR kbd_getkey              ; result in KBD_COL, KBD_ROW (zero-page)
        BCC gik_done

;;; DEBUG
;        ld16 R0,strbuf
;        LDA KBD_ROW
;        JSR fmt_bin_string
;        JSR acia_puts
;        LDA #' '
;        JSR acia_putc
;        LDA KBD_COL
;        JSR fmt_bin_string
;        JSR acia_puts
;        JSR acia_put_newline
;        RTS 
;;; DEBUG

gik_got_key:
        ; q in row 0
        ; azs are in row 1
        ; km in row 4
        BBS0 KBD_ROW,gik_test_row0
        BBS1 KBD_ROW,gik_test_row1
        BBS6 KBD_ROW,gik_test_row6
        JMP gik_done

gik_test_row0:
        ; ROW0, COL6 = "q"
        BBR6 KBD_COL,gik_clr_row0   ; If not "q", then done
        LDA #$FF                    ; else mark end-of-game
        STA pp_game                 ; in game state variable

gik_clr_row0:
        RMB0 KBD_ROW                ; clear row 0, check for other keys
        JMP gik_got_key

gik_test_row1:
        BBR2 KBD_COL, @check_z      ; check for "a"
		JSR gi_movelup
@check_z:
        BBR4 KBD_COL, @check_s      ; check for "z"
		JSR gi_moveldown
@check_s:
        BBR5 KBD_COL, gik_clr_row1      ; check for "s" (start game)
		LDA #$01
		STA pp_game

gik_clr_row1:
        RMB1 KBD_ROW                ; clear row 1, check for other keys
        JMP gik_got_key

gik_test_row6:
        BBR2 KBD_COL, @check_m      ; check for ";"
		JSR gi_moverup
@check_m:
        BBR3 KBD_COL, gik_clr_row6      ; check for "\"
		JSR gi_moverdown

gik_clr_row6:
        RMB6 KBD_ROW                ; clear row 6 and finish

gik_done:
		RTS
.endif

;---------------------------------------
; Draw paddles
draw_paddles:
		;; draw left paddle
		LDA #0
		STA ZP_TMP0		; S
		LDA #BATL_POS
		STA ZP_TMP1		; X
		LDA pp_batly
		STA ZP_TMP2		; Y
		JSR vdp_set_sprite_pos
		LDA #1
		STA ZP_TMP0		; S
		LDA #BATL_POS
		STA ZP_TMP1		; X
		LDA pp_batly
		CLC
		ADC #8
		STA ZP_TMP2		; Y+8
		JSR vdp_set_sprite_pos
		;; draw right paddle
		LDA #2
		STA ZP_TMP0		; S
		LDA #BATR_POS
		STA ZP_TMP1		; X
		LDA pp_batry
		STA ZP_TMP2		; Y
		JSR vdp_set_sprite_pos
		LDA #3
		STA ZP_TMP0		; S
		LDA #BATR_POS
		STA ZP_TMP1		; X
		LDA pp_batry
		CLC
		ADC #8
		STA ZP_TMP2		; Y+8
		JSR vdp_set_sprite_pos
		RTS

;--------------------------------------------------
; Check ball position and change speed as necessary
; Move the ball according to current speed
;
move_ball:
		; if y<top or y>bot then invert yspeed
		LDA pp_bally
        CMP #1
        BCC mb_yspeed_pos	; A < ballspeed y, bounce
		CMP #192-8
        BCS	mb_yspeed_neg	; ball is at bottom edge, bounce
		JMP mb_checkx
mb_yspeed_pos:
        LDA pp_bsy_pos		; make Y-velocity positive
		STA pp_ballyv
		JMP mb_checkx
mb_yspeed_neg:
        LDA pp_bsy_neg		; make Y-velocity negative
		STA pp_ballyv		;
		JMP mb_checkx

; X direction

mb_checkx:
		; find out if we need to check Left/Right or neither
		LDA pp_ballx
        CMP #BATL_POS+2
		BCC mb_check_batl		; Ballx < 18
		CMP #BATR_POS-2
		BCS mb_check_batr		; Ballx >= 237
		JMP mb_add_speed

mb_check_batl:
		; check ball is above bat top
		LDA pp_bally
		CLC
		ADC #7
		CMP pp_batly
		BCC mb_add_speed	; BallY+7 < bat top
		; check ball is below bat bottom
		LDA pp_batly
		CLC
		ADC #15
		CMP pp_bally
		BCC mb_add_speed	; bat bot < ball top

        ; if ball is already past bat don't hit
        LDA pp_ballx
        CMP #BATL_POS-2
        BCC mb_add_speed

		; hit bat - make ball speed positive again
mb_xspeed_pos:
        LDA pp_bsx_pos
		STA pp_ballxv
		JMP mb_add_speed

mb_xspeed_neg:
        LDA pp_bsx_neg
		STA pp_ballxv
		JMP mb_add_speed

mb_check_batr:
		; check ball is above bat top
		LDA pp_bally
		CLC
		ADC #7
		CMP pp_batry
		BCC mb_add_speed	; ball is above bat top
		; check ball is below bat bottom
		LDA pp_batry
		CLC
		ADC #15
		CMP pp_bally
		BCC mb_add_speed	; bat bot < ball top

        ; if ball is already past bat don't hit
        LDA pp_ballx
        CMP #BATR_POS+2
        BCS mb_add_speed

		; hit bat - make ball speed negative again
		JMP mb_xspeed_neg

mb_add_speed:
		; add speed to x/y
		CLC
		LDA pp_ballx
		ADC pp_ballxv
		STA pp_ballx
		CLC
		LDA pp_bally
		ADC pp_ballyv
		STA pp_bally
		RTS

;---------------------------------------
; Draw ball
draw_ball:
		;; draw ball
		LDA #4			; S=4 ball sprite
		STA ZP_TMP0
		LDA pp_ballx
		STA ZP_TMP1		; X 
		LDA pp_bally
		STA ZP_TMP2		; Y
		JSR vdp_set_sprite_pos
		RTS

;---------------------------------------
; Disable ball sprite
disable_ball:
		LDA ZP_VDP_SAB			; set address of Sprite Attribute table
		CLC
		ADC #16
		TAY
		LDA ZP_VDP_SAB+1
		JSR vdp_set_addr_w
		LDA #$D0
        JSR vdp_write
		RTS

;---------------------------------------
; Draw score
draw_score:
		LDA #10
		JSR ds_set_cursor_position
		LDA pp_scorel
		CMP #100				; check if triple digit
		BCS ds_over				; X >= 100
		INC ZP_VDP_CURS			; move right
		CMP #10					; check if double digits
		BCS ds_over				; X >= 10, X < 100
		INC ZP_VDP_CURS			; move right
ds_over:
		LDA pp_scorel			; Left score
		JSR ds_conv_decimal		; convert to decimal string in R0
		JSR vdp_write_text		; write the string

		LDA #19					; x position to put score
		JSR ds_set_cursor_position
		LDA pp_scorer
		JSR ds_conv_decimal
		JSR vdp_write_text		; write the string
		RTS

ds_conv_decimal:
		; A has number, convert to bcd in RES, RES+1
		JSR BINBCD8
		; Convert BCD number in RES to string pointed to in R0
		ld16 R0, score_buffer
		JSR BCD2STR
		RTS
		
ds_set_cursor_position:
		; A has x position, y pos is 2
		; Set cursor position in ZP_VDP_CURS
		CLC
		ADC #64					; set Y=2 on a graphics screen
		STA ZP_VDP_CURS
		STZ ZP_VDP_CURS+1
		STA ZP_VDP_XPOS
		LDA #2
		STA ZP_VDP_YPOS
		RTS
		
;---------------------------------------
; Check game conditions
; Check ball position - if going off left, inc R score
check_game:

	; Check if ball has gone off left
		LDA pp_ballx
		CMP #2
		BCS cg_check_right		; still in play (X>0)

		LDA pp_scorer
		INC
		STA pp_scorer

		LDA #96					; reset ball position
		STA pp_ballx
        LDA pp_bsx_pos
		STA pp_ballxv		
cg_check_right:
	; Check if ball has gone off right
		LDA pp_ballx
		CMP #253
		BCC cg_check_scores		; still in play (X<256)

		LDA pp_scorel
		INC
		STA pp_scorel

		LDA #96					; reset ball position
		STA pp_ballx
        LDA pp_bsx_neg
		STA pp_ballxv		
cg_check_scores:
		LDA pp_scorel
		CMP #21
		BCS cg_left_wins
		LDA pp_scorer
		CMP #21
		BCS cg_right_wins
cg_done:
		RTS

cg_left_wins:
		ld16 R0, win_left_message
		JMP cg_write_win_message
cg_right_wins:
		ld16 R0, win_right_message
cg_write_win_message:
		JSR acia_puts
		JSR acia_put_newline
		LDA #$FF
		STA pp_game
		RTS
;---------------------------------------
;
quit_game:
		ld16 R0,quit_message
		JSR acia_puts
; restore interrupt vector 
pih_restore_irq:
        LDA IRQ_OLD
        STA IRQ_ADDR
        LDA IRQ_OLD+1
        STA IRQ_ADDR+1
; disable interrupts at CPU
        SEI

; disable interrupts from VDP
        LDA VDP_REGS+1      ;; data to write is existing Reg1
        AND #$DF            ;; unset interrupt bit
        STA VDP_REGS+1
        LDY #$81            ;; register to write (1)
        JSR vdp_regwrite

        JSR vdp_getstatus   ;; clear interrupt flag in VDP

		RTS

;---------------------------------------
; Delay
delay:
		LDX #6
d_loop2:
		LDY #0
d_loop1:
		NOP
		DEY
		BNE d_loop1
		DEX
		BNE d_loop2
		RTS

;---------------------------------------
; Interrupt handler
PONG_IRQ:
        PHA

        JSR vdp_getstatus           ;; read VDP status to reenable the VDP interrupt

        LDA IRQ_COUNT               ;; if count >0
        BEQ @skip
        DEC IRQ_COUNT               ;; count--
@skip:
        PLA
        RTI
;---------------------------------------



quit_message:
	.byte "Goodbye!",$0d,$0a,$00
win_left_message:
	.byte "Player 1 Wins!",$0d,$0a,$00
win_right_message:
	.byte "Player 2 Wins!",$0d,$0a,$00
irq_message:
    .byte "Hello",$0d,$0a,$00
